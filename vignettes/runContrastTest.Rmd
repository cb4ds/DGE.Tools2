<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{DGE Tools Workflow}
%\VignetteDepends{ggplot2, magrittr}
-->
---
title: "DGE.Tools2"
author: "John Thompson (john.thompson@bms.com)"
date: '`r format.Date(Sys.Date(), "%B %d %Y")`'
header-includes:
- \usepackage{fancyhdr}
- \usepackage{graphicx}
- \pagestyle{fancy}
- \fancyhead[LE,RO]{}
- \fancyfoot[CO,CE]{\textit{BMS Confidential}}
- \fancyfoot[LE,RO]{\thepage}
output:
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
    fig_width: 7
    fig_height: 5
fontsize: 10pt
---

\newpage

#Load Libraries

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
rm(list=ls()) #Clear the workspace
invisible(gc()) #garbage collection to maximize available memory
startTime = Sys.time() #used to time the run

library(dplyr)
library(edgeR)
library(limma)
library(magrittr)
library(DGEobj)
library(DGE.Tools2)
```

#Get raw count data from an Omicsoft project

This builds a DGEobj with the mimimal set of raw data.  Here raw data is defined 
as a matrix of counts with associated dataframes to annotate the genes (row) and
samples (col) data (3 tabbed text files).

```{r getOmicsoftData}

setwd("~/R/lib/pkgsrc/DGE.Tools2/inst/extdata")
setwd("~/R/lib/pkgsrc/DGE.Tools2")
dgeObj <- OmicsoftToDgeObj(path="./inst/extdata")
# dgeObj <- OmicsoftToDgeObj()
```

#EdgeR Normalization

```{r Normalize}
setwd("~/R/lib/pkgsrc/DGE.Tools2")
dgeObj <- runEdgeRNorm(dgeObj)
```

#Filter out low intensity genes

I use a FPK + mincount filter here.

```{r LowIntensityFilter}

#low expression filter
counts <- getItem(dgeObj, "counts")
genelength <-getItem(dgeObj, "geneData")$ExonLength
fpk <- convertCounts(counts, 
                     unit="FPK", 
                     geneLength=genelength)
#keep FPK >=5 in 50% of samples
idx <- fpk >= 5.0
frac <- rowSums(fpk) / ncol(fpk)
idx <- frac >= 0.75
d1 <- dgeObj  #save for testing
dgeObj <- subset(dgeObj, idx, 1:ncol(dgeObj))
d2 <- dgeObj
```

#Define the model

Provide a formula and construct the design matrix.

```{r ModelDesign}
#define a formula and construct a design matrix
design <- getItem(dgeObj, "design")
design$ReplicateGroup %<>% as.factor
design$ReplicateGroup %<>% relevel("Normal_control")
formula <- '~ 0 + ReplicateGroup'
#build the designMatrix and add some attributes
designMatrix <- model.matrix (as.formula(formula), design)
#give this design a name
designMatrixName <- "Treatment"
#capture the formula and parent as attributes
designMatrix <- setAttributes(designMatrix, list(formula=formula))
#save the designMatrix
dgeObj <- addItem(dgeObj, item=designMatrix, 
                  itemName=designMatrixName, 
                  itemType="designMatrix",
                  parent="design")
```

#QC: Dispersion Plot

```{r DispersionPlot}

#dispersion plot
# dispPlot <- plotDisp(getItem(dgeObj, "DGEList"), designMatrix)
# dispPlot + baseTheme(18)
```

#Run Voom and fit the model (lmfit)

```{r runVoom, cache=T}
#QW and Var.design and dupCor
block <- c(1,2,3,1,2,3,4,5,6,4,5,6,7,8,9,7,8,9)
vd <- model.matrix(as.formula("~ Treatment"), design)
d1 <- runVoom(dgeObj, designMatrixName, 
              qualityWeights = TRUE,
              var.design=vd,
              dupcorBlock=block)
```

I'm getting a warning here I don't understand: 
```
Warning messages:  
1: In at[itemName] <- attribs[[i]] :
  number of items to replace is not a multiple of replacement length
2: In at[itemName] <- attribs[[i]] :
  number of items to replace is not a multiple of replacement length
```

#Data Exploration: MDS plot

```{r MDSplot}
#use color and shape with labels and labelSize
m <- ggplotMDS(d1, colorBy = design$Treatment, 
               shapeBy = design$Disease.Status, symSize =5,
               labels=design$VendorBarcode,
               labelSize=3)
print(m[[1]])
```

#Set up and run contrasts

Function runContrasts takes a named list of contrasts.  The values in the list
should correspond to columns in the design matrix.

```{r runContrasts}
#runContrast testing  
contrastList  <- list(TGF_Norm = "ReplicateGroupNormal_TGFb - ReplicateGroupNormal_control",
                      TGF_Stable = "ReplicateGroupStable_TGFb - ReplicateGroupStable_control",
                      TGF_Rapid = "ReplicateGroupRapid_TGFb - ReplicateGroupRapid_control"
)
# library(assertthat)
DgeObj_contrast <- runContrasts(d1, 
                                designMatrixName="Treatment", 
                                contrastList=contrastList, 
                                runTopTreat=T)
saveRDS(DgeObj_contrast, "../DGEobj.RDS")
```

#Check for Surrogate Variables (unaccounted for variation)

If SVA find surrogate variables,  you cbind the design table for the surrogate
variables to your experiments design matrix and then re-run voom/lmfit.

##runSVA

```{r SVA}

#sva test
dgeObj_sva <- runSVA(d1, "Treatment")
```
SVA found 5 surrogate variables in this dataset and created a new design matrix.
We'll now re-run runVoom with the new designMatrix.

##Re-Run voom/lmfit

```{r rerunVoom, cache=T}
block <- c(1,2,3,1,2,3,4,5,6,4,5,6,7,8,9,7,8,9)
vd <- model.matrix(as.formula("~ Treatment"), design)
dgeObj_sva <- runVoom(dgeObj_sva, designMatrixName="Treatment_sva", 
              qualityWeights = TRUE,
              var.design=vd,
              dupcorBlock=block)
```

##Re-run Contrasts

```{r rerunContrasts}
#runContrast testing  
contrastList  <- list(TGF_Norm = "ReplicateGroupNormal_TGFb - ReplicateGroupNormal_control",
                      TGF_Stable = "ReplicateGroupStable_TGFb - ReplicateGroupStable_control",
                      TGF_Rapid = "ReplicateGroupRapid_TGFb - ReplicateGroupRapid_control"
)
# library(assertthat)
DgeObj_contrast <- runContrasts(dgeObj_sva, 
                                designMatrixName="Treatment_sva", 
                                contrastList=contrastList, 
                                runTopTreat=T)
saveRDS(DgeObj_contrast, "../DGEobj.RDS")

```


#Alternative FDR scores

topTable provides a BH FDR value (adj.P.Val).  We provide two functions (runQvalue
and runIHW) that provide alternative FDR measures. See the help for each of those 
functions for details of how each method determines the FDR value.

Here we extract all topTable dataframes as a list.  Then we loop through and add
the specified FDR measures as additional columns in the topTable dataframes and
return the original list of dataframes.

##runQvalue

```{r runQvalue}
#Qvalue test
#extract a topTable List
contrastList <- getType(DgeObj_contrast, type="topTable", parent="Treatment_fit_cf")
contrastList2 <- runQvalue(contrastList)

#now put the contrasts back in the DGEobj
DgeObj_q <- addItems(DgeObj_contrast, 
                     itemList=contrastList2,
                     itemTypes=as.list(rep("topTable", length(contrastList2))),
                     overwrite=TRUE)
```

##runIHW

```{r runIHW}
#IHW test
#extract a topTable List
contrastList <- getType(DgeObj_contrast, type="topTable", parent="Treatment_fit_cf")
contrastList2 <- runIHW(contrastList)

#now put the contrasts back in the DGEobj
DgeObj_ihw <- addItems(DgeObj_contrast, 
                       itemList=contrastList2, 
                       itemTypes=as.list(rep("topTable", length(contrastList2))),
                       overwrite=TRUE)
```

